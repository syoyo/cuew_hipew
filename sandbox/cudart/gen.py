import json
import os, sys
import pprint

def eval_expr(expr):
    s = ""

    if expr['kind'] == 'ConstantExpr':
        inner = expr['inner']
        assert len(inner) == 1

        s += eval_expr(inner[0])

    elif expr['kind'] == 'UnaryOperator':
        opcode = expr['opcode']

        assert len(expr['inner']) == 1
        assert opcode == '-'

        s += "{}{}".format(opcode, eval_expr(expr['inner'][0]))

    elif expr['kind'] == 'IntegerLiteral':

        s += expr['value']

    elif expr['kind'] == 'BinaryOperator':
        assert len(expr['inner']) == 2

        opcode = expr['opcode']

        s += "{} {} {}".format(eval_expr(expr['inner'][0]), opcode, eval_expr(expr['inner'][1]))

    else:
        print("eval_expr: TODO:", expr)
        raise

    return s


def enum_const_expr(expr):

    if expr['kind'] == 'ConstantExpr':
        s = eval_expr(expr)
        #print("expr:", s)
    else:
        # TODO: BinaryExpr(e.g. `1 << 2`)
        print("TODO", expr)
        raise

    return s

def emit_enum(item):
    if not 'name' in item:
        # anonymous enum. Guess this is from system header(e.g. math.h)
        return None

    name = item['name']

    decls = []
    for val in item['inner']:
        if val['kind'] != 'EnumConstantDecl':
            continue

        constant_name = val['name']
        #print("const name ", constant_name)

        assert val['type']['qualType'] == 'int'

        # has value?
        if 'inner' in val:
            exprs = val['inner']

            if isinstance(exprs, list):
                expr = list(filter(lambda x: x['kind'] == 'ConstantExpr', exprs))

                if len(expr) == 0:
                    # Enum without value

                    decls.append(constant_name)

                else:

                    # 'ConstantExpr' appears only once.
                    assert len(expr) == 1

                    value_expr = enum_const_expr(expr[0])

                    decls.append("{} = {}".format(constant_name, value_expr))
            else:
                expr = exprs
                assert expr['kind'] != "FullComment"
                enum_const_expr(expr)

        else:
            decls.append(constant_name)

    #print("enum decls", decls)

    # format
    # TODO: qualifier. e.g. __device_builtin__
    s = "enum {}\n".format(name)
    s += "{\n"
    s += ",\n".join(map(lambda x: "  " + x, decls)) # append whitespace indent
    s += "\n};"
    s += " // id {} \n".format(item['id'])

    return s

def emit_header(apiname: str, prologue, epilogue, includes):

    s = "// This file is automatically generated.\n"

    s += "#ifndef CUEW_" + apiname.upper() + "_H_\n"
    s += "#define CUEW_" + apiname.upper() + "_H_\n"

    s += "\n#include <stdint.h>\n\n"
    s += "\n#include <stddef.h>\n\n"
    s += "\n#include <stdlib.h>\n\n"

    s += "#ifdef __cplusplus\n"
    s += "extern \"C\" {\n"
    s += "#endif\n"

    s += "\n"

    s += """
#ifndef CUDAAPI
#ifdef _WIN32
#  define CUDAAPI __stdcall
#  define CUDA_CB __stdcall
#else
#  define CUDAAPI
#  define CUDA_CB
#endif
#endif

/*struct cudaChannelFormatDesc; */

"""

    if prologue is not None:
        s += prologue

    print(includes)
    if includes is not None:
        s += "#ifdef __clang__\n"
        s += "#pragma clang diagnostic push\n"
        s += "#pragma clang diagnostic ignored \"-Wreserved-id-macro\"\n"
        s += "#pragma clang diagnostic ignored \"-Wpadded\"\n"
        s += "#if __has_warning(\"-Wdocumentation-deprecated-sync\")\n"
        s += "  #pragma clang diagnostic ignored \"-Wdocumentation-deprecated-sync\"\n"
        s += "#endif\n"
        s += "#endif\n"

        for inc in includes:
            s += "#include \"" + inc + "\"\n"

        s += "#ifdef __clang__\n"
        s += "#pragma clang diagnostic pop\n"
        s += "#endif\n"

    if epilogue is not None:
        s += epilogue

    s += "#endif\n"

    return s


def emit_footer(suffix: str):

    suffix = suffix.upper()

    s = """
/*
struct cudaChannelFormatDesc
{
    int                        x;
    int                        y;
    int                        z;
    int                        w;
    enum cudaChannelFormatKind f;
};
*/
"""

    s += "extern int cuewInit{}(void)".format(suffix) + ";\n\n"


    s += "\n"
    s += "#ifdef __cplusplus\n"
    s += "}\n"
    s += "#endif\n"

    return s

def emit_initializer(suffix: str, dllpaths: dict, functions):
    """
    dllpaths['win32'] and dllpaths['linux'] are looked up
    """

    suffix = suffix.upper()
    suffix_lowered = suffix.lower()

    s = """

#ifdef _MSC_VER
#  if _MSC_VER < 1900
#    define snprintf _snprintf
#  endif
#  define popen _popen
#  define pclose _pclose
#  define _CRT_SECURE_NO_WARNINGS
#endif
"""

    s += "#include \"cuew.h\"\n"
    s += "#include \"cuew_{}.h\"".format(suffix_lowered)
    s += """
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>


#ifdef _WIN32
#  define WIN32_LEAN_AND_MEAN
#  define VC_EXTRALEAN
#  include <windows.h>


/* Utility macros. */

typedef HMODULE DynamicLibrary;

#  define dynamic_library_open(path)         LoadLibraryA(path)
#  define dynamic_library_close(lib)         FreeLibrary(lib)
#  define dynamic_library_find(lib, symbol)  GetProcAddress(lib, symbol)
#else
#  include <dlfcn.h>

typedef void* DynamicLibrary;

#  define dynamic_library_open(path)         dlopen(path, RTLD_NOW)
#  define dynamic_library_close(lib)         dlclose(lib)
#  define dynamic_library_find(lib, symbol)  dlsym(lib, symbol)
#endif

/*
#define CUEW_IMPL_LIBRARY_FIND_CHECKED(lib, name) \
        name = (t##name *)dynamic_library_find(lib, #name); \
        assert(name);
*/

#define CUEW_IMPL_LIBRARY_FIND(lib, name) \
        name = (t##name *)dynamic_library_find(lib, #name);


static DynamicLibrary dynamic_library_open_find(const char **paths) {
  int i = 0;
  while (paths[i] != NULL) {
      DynamicLibrary lib = dynamic_library_open(paths[i]);
      if (lib != NULL) {
        return lib;
      }
      ++i;
  }
  return NULL;
}

"""

    s += "/*#define {}_LIBRARY_FIND_CHECKED(name) CUEW_IMPL_LIBRARY_FIND_CHECKED({}_lib, name)*/\n".format(suffix, suffix_lowered)
    s += "#define {}_LIBRARY_FIND(name) CUEW_IMPL_LIBRARY_FIND({}_lib, name)\n".format(suffix, suffix_lowered)

    s += "static DynamicLibrary {}_lib;\n\n".format(suffix_lowered)

    s += "static void cuewExit" + suffix + "(void) {\n"
    s += "  if (" + suffix_lowered + "_lib != NULL) {\n"
    s += "    /* ignore errors */\n"
    s += "    dynamic_library_close({}_lib);\n".format(suffix_lowered)
    s += "    {}_lib = NULL;\n".format(suffix_lowered)
    s += "  }\n"
    s += "}\n"
    s += "\n"


    # decl
    for fun in functions:
        s += "t{} *{};\n".format(fun, fun)

    s += "\n"

    s += "int cuewInit{}()".format(suffix) + " {\n\n"

    s += "#ifdef _WIN32\n"
    s += "  const char *paths[] = {"
    for path in dllpaths['win32']:
        s += "   \"" + path + "\",\n"
    s += "NULL};\n"
    s += "#else /* linux */\n"
    s += "  const char *paths[] = {"
    for path in dllpaths['linux']:
        s += "   \"" + path + "\",\n"
    s += "NULL};\n"
    s += "#endif\n\n"

    s += """
  static int initialized = 0;
  static int result = 0;
  int error;

  if (initialized) {
    return result;
  }

  initialized = 1;
"""

    s += "  error = atexit(cuewExit{});\n".format(suffix)

    s += """
  if (error) {
    result = -2;
    return result;
  }
"""

    s += "  {}_lib = dynamic_library_open_find(paths);\n".format(suffix_lowered)

    s += "  if (" + suffix_lowered + "_lib == NULL) { result = -1; return result; }\n"

    s += "\n"

    for fun in functions:
        s += "  {}_LIBRARY_FIND({})\n".format(suffix, fun)

    s += "  result = 0; // success\n"
    s += "  return result;\n"
    s += "}\n"

    return s


def main():

    input_filename = "cudart.json"
    config_filename = "cudart-config.json"

    if len(sys.argv) > 1:
        input_filename = sys.argv[1]

    if len(sys.argv) > 2:
        config_filename = sys.argv[2]

    j = json.loads(open(input_filename, 'r').read())

    config_j = json.loads(open(config_filename, 'r').read())

    prefix = config_j["prefix"]
    api_prefix = config_j["api_prefix"]
    lib_prefix = config_j["lib_prefix"]
    dllpaths = config_j["dllpaths"]
    allowedSymbols = config_j.get("allowedSymbols", None)
    ignoredSymbols = config_j.get("ignoredSymbols", None)

    includes = config_j.get("includes", None)

    header_prologue = None
    header_prologue_filename = config_j.get("header_prologue", None)
    if header_prologue_filename:
        header_prologue = open(header_prologue_filename, 'r').read()

    header_epilogue = None
    header_epilogue_filename = config_j.get("header_epilogue", None)
    if header_epilogue_filename:
        header_epilogue = open(header_epilogue_filename, 'r').read()

    ss = emit_header(api_prefix, header_prologue, header_epilogue, includes)

    func_names = []

    inner = j['inner']
    for item in inner:
        s = ""

        if item['kind'] == "EnumDecl":
            if 'name' in item:
                pass
            else:
                continue


            is_allowed = False

            if allowedSymbols is not None:
                if item['name'] in allowedSymbols['enum']:
                    # OK
                    is_allowed = True

            if not is_allowed:
                if not item['name'].lower().startswith(api_prefix.lower()):
                    # skip
                    continue

            if ignoredSymbols is not None:
                if item['name'] in ignoredSymbols['enum']:
                    continue

            s = emit_enum(item)

            if s:
                ss += s
                ss += "\n"

        elif item['kind'] == "TypedefDecl":

            is_allowed = False

            # ignore name which does not have `CU`, `cu`, `CUDA` or `cuda` prefix
            if item['name'].startswith('cu') or item['name'].startswith('CU') or \
                item['name'].startswith('cuda') or item['name'].startswith('CUDA'):
                # OK
                pass
            else:
                if allowedSymbols is not None:
                    if item['name'] in allowedSymbols['enum']:
                        # OK
                        is_allowed = True
                        pass
                    else:
                        # skip
                        continue

            if is_allowed == False:
                if not item['name'].lower().startswith(prefix.lower()):
                    continue

            # Assume corresponding EnumDecl has been emitted.
            if item['inner'][0]['kind'] == 'PointerType' and item['inner'][0]['inner'][0]['kind'] == "ParenType":
                # Guess function pointer. e.g. cudaStreamCallback_t
                funcproto = item['inner'][0]['inner'][0]['inner'][0]

                #print(funcproto['kind'])

                assert funcproto['kind'] == "FunctionProtoType"
                assert len(funcproto['inner']) > 1
                retty = funcproto['inner'][0]['type']['qualType']
                argtys = [x['type']['qualType'] for x in funcproto['inner'][1:]]
                #print("retty ", retty)
                #print("argtys ", argtys)

                args = ", ".join(argtys)
                s = "typedef {} (*{})({}); // id {} \n".format(retty, item['name'], args, item['id'])

            else:
                s = "typedef {} {}; // id {} \n".format(item['type']['qualType'], item['name'], item['id'])

            ss += s
            ss += "\n"

        elif item['kind'] == "RecordDecl":

            if 'name' not in item:
                continue

            print(item)
            if not item['name'].lower().startswith(prefix.lower()):
                if allowedSymbols is not None:
                    if item['name'] not in allowedSymbols[item['tagUsed']]:
                        continue
                    else:
                        pass
                else:
                    continue

            if item['tagUsed'] == 'union':
                s = "union " + item['name'] + ";\n"
            elif item['tagUsed'] == 'struct':
                s = "struct " + item['name'] + ";\n"

            ss += s

        elif item['kind'] == "FunctionDecl":

            if not item['name'].lower().startswith(prefix.lower()):
                continue

            funproto = item['type']['qualType']

            # Split at first whitespace to get resty and args.
            tys = funproto.split('(', 1)
            assert len(tys) == 2

            resty = tys[0]
            args = tys[1]


            s = "typedef {} CUDAAPI t{}({};\n".format(resty, item['name'], args)
            s += "extern t{} *{};\n".format(item['name'], item['name'])

            ss += s

            func_names.append(item['name'])

    ss += emit_footer(lib_prefix)

    output_header_filename = "cuew_" + lib_prefix + ".h"
    with open(output_header_filename, 'w') as f:
        f.write(ss)

    print("Wrote header: ", output_header_filename)

    # Write symbol initializer
    ss = emit_initializer(lib_prefix, dllpaths, func_names)

    impl_filename = os.path.splitext(output_header_filename)[0] + ".c"
    with open(impl_filename, 'w') as f:
        f.write(ss)

    print("Wrote impl: ", impl_filename)


if __name__ == '__main__':
    main()
