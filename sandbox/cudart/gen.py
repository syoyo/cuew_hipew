import json
import os, sys

def eval_expr(expr):
    s = ""

    if expr['kind'] == 'ConstantExpr':
        inner = expr['inner']
        assert len(inner) == 1

        s += eval_expr(inner[0])

    elif expr['kind'] == 'UnaryOperator':
        opcode = expr['opcode']

        assert len(expr['inner']) == 1
        assert opcode == '-'

        s += "{}{}".format(opcode, eval_expr(expr['inner'][0]))

    elif expr['kind'] == 'IntegerLiteral':

        s += expr['value']

    elif expr['kind'] == 'BinaryOperator':
        assert len(expr['inner']) == 2

        opcode = expr['opcode']

        s += "{} {} {}".format(eval_expr(expr['inner'][0]), opcode, eval_expr(expr['inner'][1]))

    else:
        print("eval_expr: TODO:", expr)
        raise

    return s


def enum_const_expr(expr):

    if expr['kind'] == 'ConstantExpr':
        s = eval_expr(expr)
        #print("expr:", s)
    else:
        # TODO: BinaryExpr(e.g. `1 << 2`)
        print("TODO", expr)
        raise

    return s

def emit_enum(item):
    if not 'name' in item:
        # anonymous enum. Guess this is from system header(e.g. math.h)
        return None

    name = item['name']

    decls = []
    for val in item['inner']:
        if val['kind'] != 'EnumConstantDecl':
            continue

        constant_name = val['name']
        #print("const name ", constant_name)

        assert val['type']['qualType'] == 'int'

        # has value?
        if 'inner' in val:
            exprs = val['inner']

            if isinstance(exprs, list):
                expr = list(filter(lambda x: x['kind'] == 'ConstantExpr', exprs))

                if len(expr) == 0:
                    # Enum without value

                    decls.append(constant_name)

                else:

                    # 'ConstantExpr' appears only once.
                    assert len(expr) == 1

                    value_expr = enum_const_expr(expr[0])

                    decls.append("{} = {}".format(constant_name, value_expr))
            else:
                expr = exprs
                assert expr['kind'] != "FullComment"
                enum_const_expr(expr)

        else:
            decls.append(constant_name)

    #print("enum decls", decls)

    # format
    # TODO: qualifier. e.g. __device_builtin__
    s = "enum {}\n".format(name)
    s += "{\n"
    s += ",\n".join(map(lambda x: "  " + x, decls)) # append whitespace indent
    s += "\n};"
    s += " // id {} \n".format(item['id'])

    return s

def emit_header():

    s = "// This file is automatically generated.\n"

    s += "\n#include <stdint.h>\n\n"
    s += "\n#include <stddef.h>\n\n"

    s += "#ifdef __cplusplus\n"
    s += "extern \"C\" {\n"
    s += "#endif\n"

    s += "\n"

    s += """
#ifndef CUDAAPI
#ifdef _WIN32
#  define CUDAAPI __stdcall
#  define CUDA_CB __stdcall
#else
#  define CUDAAPI
#  define CUDA_CB
#endif
#endif

struct dim3
{
    unsigned int x, y, z;
};
typedef struct dim3 dim3;

struct cudaChannelFormatDesc;

    """


    return s


def emit_footer():

    s = """
struct cudaChannelFormatDesc
{
    int                        x;
    int                        y;
    int                        z;
    int                        w;
    enum cudaChannelFormatKind f;
};
"""


    s = "\n"
    s += "#ifdef __cplusplus\n"
    s += "}\n"
    s += "#endif\n"

    return s

def emit_initializer(suffix: str, dllpaths: dict, functions):
    """
    dllpaths['win32'] and dllpaths['linux'] are looked up
    """

    suffix = suffix.upper()
    suffix_lowered = suffix.lower()

    s = """

#ifdef _MSC_VER
#  if _MSC_VER < 1900
#    define snprintf _snprintf
#  endif
#  define popen _popen
#  define pclose _pclose
#  define _CRT_SECURE_NO_WARNINGS
#endif
"""

    s += "#include \"{}.h\"".format(suffix_lowered)
    s += """
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>


#ifdef _WIN32
#  define WIN32_LEAN_AND_MEAN
#  define VC_EXTRALEAN
#  include <windows.h>


/* Utility macros. */

typedef HMODULE DynamicLibrary;

#  define dynamic_library_open(path)         LoadLibraryA(path)
#  define dynamic_library_close(lib)         FreeLibrary(lib)
#  define dynamic_library_find(lib, symbol)  GetProcAddress(lib, symbol)
#else
#  include <dlfcn.h>

typedef void* DynamicLibrary;

#  define dynamic_library_open(path)         dlopen(path, RTLD_NOW)
#  define dynamic_library_close(lib)         dlclose(lib)
#  define dynamic_library_find(lib, symbol)  dlsym(lib, symbol)
#endif

#define _LIBRARY_FIND_CHECKED(lib, name) \
        name = (t##name *)dynamic_library_find(lib, #name); \
        assert(name);

#define _LIBRARY_FIND(lib, name) \
        name = (t##name *)dynamic_library_find(lib, #name);


static DynamicLibrary dynamic_library_open_find(const char **paths) {
  int i = 0;
  while (paths[i] != NULL) {
      DynamicLibrary lib = dynamic_library_open(paths[i]);
      if (lib != NULL) {
        return lib;
      }
      ++i;
  }
  return NULL;
}

/* hack */
tcudaStreamGetFlags *cudaStreamGetFlags;
"""

    s += "#define {}_LIBRARY_FIND_CHECKED(name) _LIBRARY_FIND_CHECKED({}_lib, name)\n".format(suffix, suffix_lowered)
    s += "#define {}_LIBRARY_FIND(name) _LIBRARY_FIND({}_lib, name)\n".format(suffix, suffix_lowered)

    s += "static DynamicLibrary {}_lib;\n\n".format(suffix_lowered)

    s += "int Init{}()".format(suffix) + " {\n\n"

    s += "#ifdef _WIN32\n"
    s += "  const char *paths[] = {"
    for path in dllpaths['win32']:
        s += "   \"" + path + "\",\n"
    s += "NULL};\n"
    s += "#else /* linux */\n"
    s += "  const char *paths[] = {"
    for path in dllpaths['linux']:
        s += "   \"" + path + "\",\n"
    s += "NULL};\n"
    s += "#endif\n\n"

    s += """
  static int initialized = 0;
  static int result = 0;
  int error;

  if (initialized) {
    return result;
  }

  initialized = 1;

  /* TODO */
  /*error = atexit(cuewExitNvrtc);
  if (error) {
    result = CUEW_ERROR_ATEXIT_FAILED;
    return result;
  }
  */
"""

    s += "  {}_lib = dynamic_library_open_find(paths);\n".format(suffix_lowered)

    s += "  if (" + suffix_lowered + "_lib == NULL) { result = -1; return result; }\n"

    s += "\n"

    for fun in functions:
        s += "  {}_LIBRARY_FIND({});\n".format(suffix, fun)

    s += "  result = 0; // success\n"
    s += "  return result;\n"
    s += "}\n"

    return s


def main():

    # HACK
    funs = ["cudaStreamGetFlags"]
    dllpaths = {}
    dllpaths['win32'] = ['cudart.dll']
    dllpaths['linux'] = ['libcudart.so', '/usr/local/cuda/lib64/libcudart.so']
    ret = emit_initializer("cudart", dllpaths, funs)
    print(ret)
    sys.exit(-1)

    input_filename = "cudart.json"
    api_prefix = "cuda"
    output_filename = os.path.splitext(input_filename)[0] + ".h"

    if len(sys.argv) > 1:
        input_filename = sys.argv[1]

    if len(sys.argv) > 2:
        api_prefix = sys.argv[2]

    if len(sys.argv) > 3:
        output_filename = sys.argv[3]

    j = json.loads(open(input_filename, 'r').read())

    ss = emit_header()

    inner = j['inner']
    for item in inner:
        s = ""

        if item['kind'] == "EnumDecl":
            s = emit_enum(item)

            if s:
                ss += s
                ss += "\n"

        elif item['kind'] == "TypedefDecl":

            # ignore name which does not have `CU`, `cu`, `CUDA` or `cuda` prefix
            if item['name'].startswith('cu') or item['name'].startswith('CU') or \
                item['name'].startswith('cuda') or item['name'].startswith('CUDA'):
                # OK
                pass
            else:
                continue

            if not item['name'].lower().startswith(api_prefix.lower()):
                continue

            # Assume corresponding EnumDecl has been emitted.
            if item['inner'][0]['kind'] == 'PointerType' and item['inner'][0]['inner'][0]['kind'] == "ParenType":
                # Guess function pointer. e.g. cudaStreamCallback_t
                funcproto = item['inner'][0]['inner'][0]['inner'][0]

                #print(funcproto['kind'])

                assert funcproto['kind'] == "FunctionProtoType"
                assert len(funcproto['inner']) > 1
                retty = funcproto['inner'][0]['type']['qualType']
                argtys = [x['type']['qualType'] for x in funcproto['inner'][1:]]
                #print("retty ", retty)
                #print("argtys ", argtys)

                args = ", ".join(argtys)
                s = "typedef {} (*{})({}); // id {} \n".format(retty, item['name'], args, item['id'])

            else:
                s = "typedef {} {}; // id {} \n".format(item['type']['qualType'], item['name'], item['id'])

            ss += s
            ss += "\n"

        elif item['kind'] == "RecordDecl":
            # TODO
            pass

        elif item['kind'] == "FunctionDecl":

            if not item['name'].lower().startswith(api_prefix.lower()):
                continue

            funproto = item['type']['qualType']

            # Split at first whitespace to get resty and args.
            tys = funproto.split('(', 1)
            assert len(tys) == 2

            resty = tys[0]
            args = tys[1]


            s = "typedef {} CUDAAPI t{}({};\n".format(resty, item['name'], args)
            s += "extern t{} *{};\n".format(item['name'], item['name'])

            ss += s

    ss += emit_footer()

    with open(output_filename, 'w') as f:
        f.write(ss)

    print("Wrote: ", output_filename)

if __name__ == '__main__':
    main()
