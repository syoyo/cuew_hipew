import json
import os, sys
import pprint

def eval_expr(expr):
    s = ""

    if expr['kind'] == 'ConstantExpr':
        inner = expr['inner']
        assert len(inner) == 1

        s += eval_expr(inner[0])

    elif expr['kind'] == 'UnaryOperator':
        opcode = expr['opcode']

        assert len(expr['inner']) == 1
        assert opcode == '-'

        s += "{}{}".format(opcode, eval_expr(expr['inner'][0]))

    elif expr['kind'] == 'IntegerLiteral':

        s += expr['value']

    elif expr['kind'] == 'BinaryOperator':
        assert len(expr['inner']) == 2

        opcode = expr['opcode']

        s += "{} {} {}".format(eval_expr(expr['inner'][0]), opcode, eval_expr(expr['inner'][1]))

    elif expr['kind'] == 'DeclRefExpr':
        # Assume '= CONST_SYMBOL'
        assert expr['valueCategory'] == 'rvalue'
        assert expr['referencedDecl']['kind'] == 'EnumConstantDecl'
        assert expr['referencedDecl']['type']['qualType'] == 'int'

        s += "{}".format(expr['referencedDecl']['name'])
    else:
        print("eval_expr: TODO:", expr)
        raise

    return s


def enum_const_expr(expr):

    if expr['kind'] == 'ConstantExpr':
        s = eval_expr(expr)
        #print("expr:", s)
    else:
        # TODO: BinaryExpr(e.g. `1 << 2`)
        print("TODO", expr)
        raise

    return s


def emit_enum(is_typedef, tagname, item):

    decls = []
    for val in item['inner']:
        if val['kind'] != 'EnumConstantDecl':
            continue

        constant_name = val['name']

        assert val['type']['qualType'] == 'int'

        # has value?
        if 'inner' in val:
            exprs = val['inner']

            if isinstance(exprs, list):
                expr = list(filter(lambda x: x['kind'] == 'ConstantExpr', exprs))

                if len(expr) == 0:
                    # Enum without value

                    decls.append(constant_name)

                else:

                    # 'ConstantExpr' appears only once.
                    assert len(expr) == 1

                    value_expr = enum_const_expr(expr[0])

                    decls.append("{} = {}".format(constant_name, value_expr))
            else:
                expr = exprs
                assert expr['kind'] != "FullComment"
                enum_const_expr(expr)

        else:
            decls.append(constant_name)

    #print("enum decls", decls)

    # format
    # TODO: qualifier. e.g. __device_builtin__

    if is_typedef:
        s = "typedef enum \n"
        s += "{\n"
        s += ",\n".join(map(lambda x: "  " + x, decls)) # append whitespace indent
        s += "\n} " + tagname + ";"
        s += " // id {} \n".format(item['id'])
    else:
        s = "enum {}\n".format(tagname)
        s += "{\n"
        s += ",\n".join(map(lambda x: "  " + x, decls)) # append whitespace indent
        s += "\n};"
        s += " // id {} \n".format(item['id'])

    return s

def emit_header(apiname: str, prologue, epilogue, includes):

    s = "/* This file is automatically generated. */\n"

    s += "#ifndef HIPEW_" + apiname.upper() + "_H_\n"
    s += "#define HIPEW_" + apiname.upper() + "_H_\n"

    s += "\n#include <stdint.h>\n\n"
    s += "\n#include <stddef.h>\n\n"
    s += "\n#include <stdlib.h>\n\n"

    s += "#ifdef __cplusplus\n"
    s += "extern \"C\" {\n"
    s += "#endif\n"

    s += "\n"

    s += """

"""

    if prologue is not None:
        s += prologue

    print(includes)
    if includes is not None:
        s += "#ifdef __clang__\n"
        s += "#pragma clang diagnostic push\n"
        s += "#pragma clang diagnostic ignored \"-Wreserved-id-macro\"\n"
        s += "#pragma clang diagnostic ignored \"-Wpadded\"\n"
        s += "#if __has_warning(\"-Wdocumentation-deprecated-sync\")\n"
        s += "  #pragma clang diagnostic ignored \"-Wdocumentation-deprecated-sync\"\n"
        s += "#endif\n"
        s += "#endif\n"

        for inc in includes:
            s += "#include \"" + inc + "\"\n"

        s += "#ifdef __clang__\n"
        s += "#pragma clang diagnostic pop\n"
        s += "#endif\n"

    if epilogue is not None:
        s += epilogue

    return s


def emit_footer(suffix: str):

    suffix = suffix.upper()

    s = ""

    if suffix == "hip":
        s += "extern int hipewInit(const char **extra_dll_search_paths);\n\n"
    else:
        s += "extern int hipewInit{}(const char **extra_dll_search_paths)".format(suffix) + ";\n\n"


    s += "\n"
    s += "#ifdef __cplusplus\n"
    s += "}\n"
    s += "#endif\n"

    s += "#endif /* HIPEW_" + suffix.upper() + "_H_ */\n"

    return s

def emit_initializer(suffix: str, dllpaths: dict, functions):
    """
    dllpaths['win32'] and dllpaths['linux'] are looked up
    """

    suffix = suffix.upper()
    suffix_lowered = suffix.lower()

    s = """

#ifdef _MSC_VER
#  if _MSC_VER < 1900
#    define snprintf _snprintf
#  endif
#  define popen _popen
#  define pclose _pclose
#  define _CRT_SECURE_NO_WARNINGS
#endif
"""

    s += "#include \"hipew.h\"\n"

    if suffix != "hip":
        s += "#include \"hipew_{}.h\"".format(suffix_lowered)

    s += """
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>


#ifdef _WIN32
#  define WIN32_LEAN_AND_MEAN
#  define VC_EXTRALEAN
#  include <windows.h>


/* Utility macros. */

typedef HMODULE DynamicLibrary;

#  define dynamic_library_open(path)         LoadLibraryA(path)
#  define dynamic_library_close(lib)         FreeLibrary(lib)
#  define dynamic_library_find(lib, symbol)  GetProcAddress(lib, symbol)
#else
#  include <dlfcn.h>

typedef void* DynamicLibrary;

#  define dynamic_library_open(path)         dlopen(path, RTLD_NOW)
#  define dynamic_library_close(lib)         dlclose(lib)
#  define dynamic_library_find(lib, symbol)  dlsym(lib, symbol)
#endif

/*
#define HIPEW_IMPL_LIBRARY_FIND_CHECKED(lib, name) \
        name = (t##name *)dynamic_library_find(lib, #name); \
        assert(name);
*/

#define HIPEW_IMPL_LIBRARY_FIND(lib, name) \
        name = (t##name *)dynamic_library_find(lib, #name);


static DynamicLibrary dynamic_library_open_find(const char **paths) {
  int i = 0;
  while (paths[i] != NULL) {
      DynamicLibrary lib = dynamic_library_open(paths[i]);
      if (lib != NULL) {
        return lib;
      }
      ++i;
  }
  return NULL;
}

"""

    s += "/*#define {}_LIBRARY_FIND_CHECKED(name) HIPEW_IMPL_LIBRARY_FIND_CHECKED({}_lib, name)*/\n".format(suffix, suffix_lowered)
    s += "#define {}_LIBRARY_FIND(name) HIPEW_IMPL_LIBRARY_FIND({}_lib, name)\n".format(suffix, suffix_lowered)

    s += "static DynamicLibrary {}_lib;\n\n".format(suffix_lowered)

    if suffix == "hip":
        s += "static void hipewExit(void) {\n"
    else:
        s += "static void hipewExit" + suffix + "(void) {\n"

    s += "  if (" + suffix_lowered + "_lib != NULL) {\n"
    s += "    /* ignore errors */\n"
    s += "    dynamic_library_close({}_lib);\n".format(suffix_lowered)
    s += "    {}_lib = NULL;\n".format(suffix_lowered)
    s += "  }\n"
    s += "}\n"
    s += "\n"


    # decl
    for fun in functions:
        s += "t{} *{};\n".format(fun, fun)

    s += "\n"

    if suffix == "hip":
        s += "int hipewInit(const char **extra_dll_search_paths) {\n\n"
    else:
        s += "int hipewInit{}(const char **extra_dll_search_paths)".format(suffix) + " {\n\n"

    s += "#ifdef _WIN32\n"
    s += "  const char *paths[] = {"
    for path in dllpaths['win32']:
        s += "   \"" + path + "\",\n"
    s += "NULL};\n"
    s += "#else /* linux */\n"
    s += "  const char *paths[] = {"
    for path in dllpaths['linux']:
        s += "   \"" + path + "\",\n"
    s += "NULL};\n"
    s += "#endif\n\n"

    s += """
  static int initialized = 0;
  static int result = 0;
  int error;

  if (initialized) {
    return result;
  }

  initialized = 1;
"""

    if suffix == "hip":
        s += "  error = atexit(hipewExit);\n"
    else:
        s += "  error = atexit(hipewExit{});\n".format(suffix)

    s += """
  if (error) {
    result = -2;
    return result;
  }
"""

    s += "  {}_lib = dynamic_library_open_find(paths);\n".format(suffix_lowered)

    s += "  if (" + suffix_lowered + "_lib == NULL) { \n"
    s += "    if (extra_dll_search_paths) { \n"
    s += "      {}_lib = dynamic_library_open_find(extra_dll_search_paths);\n".format(suffix_lowered)
    s += "    }\n"
    s += "  }\n"

    s += "  if (" + suffix_lowered + "_lib == NULL) { result = -1; return result; }\n"

    s += "\n"

    for fun in functions:
        s += "  {}_LIBRARY_FIND({})\n".format(suffix, fun)

    s += "  result = 0; // success\n"
    s += "  return result;\n"
    s += "}\n"

    return s


def main():

    input_filename = "hip.json"
    config_filename = "hip-config.json"

    if len(sys.argv) > 1:
        input_filename = sys.argv[1]

    if len(sys.argv) > 2:
        config_filename = sys.argv[2]

    j = json.loads(open(input_filename, 'r').read())

    config_j = json.loads(open(config_filename, 'r').read())

    prefix = config_j["prefix"]
    api_prefix = config_j["api_prefix"]
    lib_prefix = config_j["lib_prefix"]
    dllpaths = config_j["dllpaths"]
    allowedSymbols = config_j.get("allowedSymbols", None)
    ignoredSymbols = config_j.get("ignoredSymbols", None)

    includes = config_j.get("includes", None)

    header_prologue = None
    header_prologue_filename = config_j.get("header_prologue", None)
    if header_prologue_filename:
        header_prologue = open(header_prologue_filename, 'r').read()

    header_epilogue = None
    header_epilogue_filename = config_j.get("header_epilogue", None)
    if header_epilogue_filename:
        header_epilogue = open(header_epilogue_filename, 'r').read()

    ss = emit_header(api_prefix, header_prologue, header_epilogue, includes)

    func_names = []

    emitted_symbols = []

    inner = j['inner']
    for idx, item in enumerate(inner):
        s = ""

        if item['kind'] == "EnumDecl":
            tagname = None
            is_typedef = False

            if 'name' in item:
                tagname = item['name']
                pass
            else:
                # Guess
                # typedef enum {
                # ...
                # } tagname;
                # => Subsequent inner item has 'TypedefDecl' kind
                if idx + 1 < len(inner):
                    if inner[idx+1]['kind'] == 'TypedefDecl':
                        if 'name' in inner[idx+1]:
                            tagname = inner[idx+1]['name']
                            is_typedef = True

            if tagname == None:
                # Gues system types
                continue

            is_allowed = False

            if allowedSymbols is not None:
                if tagname in allowedSymbols['enum']:
                    # OK
                    is_allowed = True

            if not is_allowed:
                if not tagname.lower().startswith(api_prefix.lower()):
                    # skip
                    continue

            if ignoredSymbols is not None:
                if tagname in ignoredSymbols['enum']:
                    continue

            s = emit_enum(is_typedef, tagname, item)

            if s:
                ss += s
                ss += "\n"

            if is_typedef:
                # Do not emit typedef in subsequent item['kind'] == `TypedefDecl` clauase
                emitted_symbols.append(tagname)

        elif item['kind'] == "TypedefDecl":

            is_allowed = False

            if ignoredSymbols is not None:
                if item['name'] in ignoredSymbols['typedef']:
                    continue

            if item['name'].startswith('hip') or item['name'].startswith('HIP'):
                # OK
                pass
            else:
                if allowedSymbols is not None:
                    if item['name'] in allowedSymbols['enum']:
                        # OK
                        is_allowed = True

            if is_allowed == False:
                if not item['name'].lower().startswith(api_prefix.lower()):
                    continue

            if tagname in emitted_symbols:
                # typedef is already emitted.
                continue

            # Assume corresponding EnumDecl has been emitted.
            if item['inner'][0]['kind'] == 'PointerType' and item['inner'][0]['inner'][0]['kind'] == "ParenType":
                # Guess function pointer. e.g. cudaStreamCallback_t
                funcproto = item['inner'][0]['inner'][0]['inner'][0]

                #print(funcproto['kind'])

                assert funcproto['kind'] == "FunctionProtoType"
                assert len(funcproto['inner']) > 1
                retty = funcproto['inner'][0]['type']['qualType']
                argtys = [x['type']['qualType'] for x in funcproto['inner'][1:]]
                #print("retty ", retty)
                #print("argtys ", argtys)

                args = ", ".join(argtys)
                s = "typedef {} (*{})({}); // id {} \n".format(retty, item['name'], args, item['id'])

            elif item['inner'][0]['kind'] == 'PointerType' and (len(item['inner'][0]['inner']) == 1):

                if 'ownedTagDecl' in item['inner'][0]['inner']:
                    continue

                # Guess typedef XYZ* XYZ_t
                ty = item['inner'][0]['type']['qualType']

                s = "typedef {} {}; // id {} \n".format(ty, item['name'], item['id'])
            elif item['inner'][0]['kind'] == 'ConstantArrayType':
                ty = item['inner'][0]['inner'][0]['type']['qualType']
                sz = item['inner'][0]['size']

                s = "typedef {} {}[{}]; // id {} \n".format(ty, item['name'], sz, item['id'])
            else:
                s = "typedef {} {}; // id {} \n".format(item['type']['qualType'], item['name'], item['id'])

            ss += s
            ss += "\n"

        elif item['kind'] == "RecordDecl":

            if 'name' not in item:
                continue

            tagname = item['name']

            #tagname = None
            #is_typedef = False

            #completeDefinition = item.get('completeDefinition', False)

            #if 'name' in item:
            #    tagname = item['name']
            #    pass
            #else:
            #    # Guess
            #    # typedef struct {
            #    # ...
            #    # } tagname;
            #    # => Subsequent inner item has 'TypedefDecl' kind
            #    if idx + 1 < len(inner):
            #        if inner[idx+1]['kind'] == 'TypedefDecl':
            #            if 'name' in inner[idx+1]:
            #                tagname = inner[idx+1]['name']
            #                is_typedef = True

            if tagname == None:
                # Gues RecordDecl from system headers
                continue

            if not tagname.lower().startswith(prefix.lower()):
                if allowedSymbols is not None:
                    if tagname not in allowedSymbols[item['tagUsed']]:
                        continue
                    else:
                        pass
                else:
                    continue


            if item['tagUsed'] == 'union':
                s = "union " + tagname + ";\n"
            elif item['tagUsed'] == 'struct':
                s = "struct " + tagname + ";\n"

            ss += s

        elif item['kind'] == "FunctionDecl":

            if not item['name'].lower().startswith(prefix.lower()):
                continue

            funproto = item['type']['qualType']

            # Split at first whitespace to get resty and args.
            tys = funproto.split('(', 1)
            assert len(tys) == 2

            resty = tys[0]
            args = tys[1]


            s = "typedef {} t{}({};\n".format(resty, item['name'], args)
            s += "extern t{} *{};\n".format(item['name'], item['name'])

            ss += s

            func_names.append(item['name'])

    ss += emit_footer(lib_prefix)

    if lib_prefix == "hip":
        output_header_filename = "hipew.h"
    else:
        output_header_filename = "hipew_" + lib_prefix + ".h"
    with open(output_header_filename, 'w') as f:
        f.write(ss)

    print("Wrote header: ", output_header_filename)

    # Write symbol initializer
    ss = emit_initializer(lib_prefix, dllpaths, func_names)

    impl_filename = os.path.splitext(output_header_filename)[0] + ".c"
    with open(impl_filename, 'w') as f:
        f.write(ss)

    print("Wrote impl: ", impl_filename)


if __name__ == '__main__':
    main()
